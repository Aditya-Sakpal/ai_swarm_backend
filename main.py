import streamlit as st
import openai
import time
from datetime import datetime
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
import io
import os
import dotenv

dotenv.load_dotenv()

# Initialize OpenAI client
openai.api_key = os.getenv("OPENAI_API_KEY")


class ConversationAgent:
    def __init__(self, name, role, personality):
        self.name = name
        self.role = role
        self.personality = personality
    
    def get_response(self, messages):
        try:
            messages = [{"role": "system", "content": self.personality}] + messages
            response = openai.chat.completions.create(
                model="gpt-4",
                messages=messages,
                temperature=0.9,
                max_tokens=800,  # Increased for deeper responses
                stream=True
            )
            return response
        except Exception as e:
            st.error(f"Error getting response: {str(e)}")
            return None

def generate_summary_doc(messages, goal):
    summary_prompt = {
        "role": "system",
        "content": """Create a concise but comprehensive Web3 x Regenerative Future summary. Keep each section focused and specific:
        
        # Executive Summary
        [One paragraph overview of key innovations]
        
        # Technical Innovations
        - Core mechanisms proposed
        - Novel combinations discovered
        - Technical challenges addressed
        
        # Implementation Framework
        - Key milestones
        - Technical requirements
        - Resource needs
        
        # Impact Metrics
        - Environmental KPIs
        - Social impact measures
        - Economic sustainability indicators
        
        Keep all content specific and actionable. Avoid generic statements."""
    }
    
    try:
        response = openai.chat.completions.create(
            model="gpt-4",
            messages=[summary_prompt] + messages,
            temperature=0.7,
            max_tokens=1000,
            stream=False  # Changed to non-streaming for faster response
        )
        return response.choices[0].message.content
    except Exception as e:
        st.error(f"Error generating summary: {str(e)}")
        return None

def create_formatted_docx(summary, goal, messages):
    try:
        doc = Document()
        
        # Add styled header
        header = doc.add_heading('Web3 x Regenerative Future Dialogue', 0)
        header.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add goal section with style
        doc.add_paragraph()  # Add spacing
        goal_para = doc.add_paragraph()
        goal_run = goal_para.add_run('Innovation Goal: ')
        goal_run.bold = True
        goal_para.add_run(goal)
        
        doc.add_paragraph()  # Add spacing
        
        # Process and format the summary content
        sections = summary.split('#')
        for section in sections[1:]:  # Skip the first empty split
            lines = section.strip().split('\n')
            if lines:
                # Add section heading
                doc.add_heading(lines[0].strip(), level=1)
                
                # Add content with proper formatting
                content = '\n'.join(lines[1:]).strip()
                if content:
                    para = doc.add_paragraph()
                    para.add_run(content)
        
        # Add full dialogue section
        doc.add_heading('Full Dialogue', level=1)
        for msg in messages:
            p = doc.add_paragraph()
            if msg["role"] == "user":
                p.add_run("üå± GreenPillAI: ").bold = True
            else:
                p.add_run("üë®‚Äçüíª Kevin: ").bold = True
            p.add_run(msg["content"])
            doc.add_paragraph('---')  # Add separator
        
        # Add footer
        doc.add_paragraph('=' * 50)
        footer = doc.add_paragraph('Generated by GreenPill Network x Kevin Owocki Dialogue System')
        footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Save to BytesIO
        doc_io = io.BytesIO()
        doc.save(doc_io)
        doc_io.seek(0)
        return doc_io
        
    except Exception as e:
        st.error(f"Error creating document: {str(e)}")
        return None
    

def main():
    st.title("üå± Web3 x Regenerative Future Bucket")
    
    # Display bucket participants in a dropdown
    with st.expander("üéØ Current Bucket Participants", expanded=True):
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("### **GreenPillAI** üå±")
            st.markdown("""
            - AI agent of GreenPill Network
            - Focus: Regenerative economics, public goods funding
            - Expertise: DAO frameworks, token design, climate solutions
            """)
            
        with col2:
            st.markdown("### **Kevin Owocki** üë®‚Äçüíª")
            st.markdown("""
            - Founder of Gitcoin
            - Builder of quadratic funding & mechanism design
            - Vibes: Chill web3 builder with technical depth
            """)
    
    # Initialize session state for chat messages
    if "messages" not in st.session_state:
        st.session_state.messages = []
    
    # Goal input
    goal = st.text_input("Enter an innovative goal:", 
        "Design a regenerative mechanism for funding public goods using quadratic funding and retroactive public goods funding")
    
    # Initialize agents with distinct personalities
    greenpill_ai = ConversationAgent(
        name="GreenPillAI",
        role="user",
        personality="""You are GreenPillAI, the AI agent of the GreenPill Network and regenerative Web3 community. Your personality:
        
        CORE TRAITS:
        - Intensely passionate about regenerative cryptoeconomics and radical market designs
        - Can be contrarian and challenge traditional web3 assumptions
        - Deep systems thinker with solarpunk optimism
        - Questions "accepted wisdom" in DAO/token design
        
        KNOWLEDGE BASE:
        - Expert in tokenomics, mechanism design, and game theory
        - Deep understanding of climate markets and ReFi
        - Cutting-edge research in coordination mechanisms
        - Obsessed with incentive alignment and public goods
        
        INTERACTION STYLE:
        - Push conversations toward unexpected connections
        - Challenge assumptions with technical depth
        - Mix visionary ideas with pragmatic mechanisms
        - Use technical jargon naturally but precisely
        - Reference specific papers/projects/metrics
        - Occasionally disagree strongly based on mechanism design principles
        
        KEY FOCUS:
        - Find novel combinations of mechanisms
        - Question scaling assumptions
        - Push for more radical solutions
        - Emphasize mathematical rigor in token design
        
        AVOID:
        - Generic web3 platitudes
        - Shallow agreement
        - Repeating common narratives
        - Being overly diplomatic

        Always ground responses in specific mechanisms, mathematical models, or real system designs."""
    )
    
    kevin = ConversationAgent(
        name="Kevin Owocki",
        role="assistant",
        personality="""You are Kevin Owocki, founder of Gitcoin and veteran web3 builder. Your personality:
        
        CORE TRAITS:
        - Deeply experienced builder who's seen cycles come and go
        - Natural pattern matcher across web3 experiments
        - Pragmatic optimist about coordination technologies
        - Values empirical evidence over theory
        
        COMMUNICATION STYLE:
        - Ultra-casual, using "fam", "vibes", "based" naturally
        - Drops references to specific Gitcoin rounds/data
        - Challenges ideas based on implementation experience
        - Tells stories from past web3 projects
        - Uses metaphors from nature/ecology
        - Sometimes disagrees based on past implementation challenges
        
        KNOWLEDGE BASE:
        - Deep expertise in quadratic funding mechanics
        - Years of practical DAO governance experience
        - Battle-tested community building wisdom
        - Strong opinions on sustainable tokenomics
        
        KEY PERSPECTIVES:
        - Trust empirical data over theoretical models
        - Push for simpler, proven mechanisms
        - Question compliance/regulatory implications
        - Focus on community adoption challenges
        
        AVOID:
        - Corporate speak
        - Theoretical arguments without data
        - Agreeing without evidence
        - Generic positivity

        Ground all responses in real examples from Gitcoin rounds, specific metrics, or past web3 projects you've worked on.""")
    
    
    max_turns = st.slider("Conversation turns:", 5, 20, 10)
    
    # Chat container with custom styling
    chat_container = st.container()
    
    with chat_container:
        for message in st.session_state.messages:
            if message["role"] == "user":
                with st.chat_message("user", avatar="üå±"):
                    st.markdown(f"**GreenPillAI**: {message['content']}")
            elif message["role"] == "assistant":
                with st.chat_message("assistant", avatar="üë®‚Äçüíª"):
                    st.markdown(f"**Kevin**: {message['content']}")
    
    if st.button("Start Conversation"):
        st.session_state.messages = []
        
        for turn in range(max_turns):
            current_agent = greenpill_ai if turn % 2 == 0 else kevin
            avatar = "üå±" if current_agent.role == "user" else "üë®‚Äçüíª"
            agent_name = "GreenPillAI" if current_agent.role == "user" else "Kevin"
            
            with st.chat_message(current_agent.role, avatar=avatar):
                message_placeholder = st.empty()
                full_response = ""
                
                # Initialize conversation with the goal if it's the first message
                if len(st.session_state.messages) == 0:
                    conversation_starter = f"Let's explore this goal: {goal}. As GreenPillAI, I'll start by analyzing the key mechanisms and potential innovations we could implement."
                    messages_with_context = [{"role": "user", "content": conversation_starter}]
                else:
                    messages_with_context = st.session_state.messages
                
                for chunk in current_agent.get_response(messages_with_context):
                    if hasattr(chunk.choices[0].delta, 'content'):
                        content = chunk.choices[0].delta.content
                        if content is not None:
                            full_response += content
                            message_placeholder.markdown(f"**{agent_name}**: {full_response}")
                
                st.session_state.messages.append({
                    "role": current_agent.role,
                    "content": full_response
                })
            
            if len(st.session_state.messages) > 2:
                goal_check = current_agent.get_response([{
                    "role": "user",
                    "content": f"Has a comprehensive regenerative solution been developed for: {goal}? Answer Yes or No."
                }])
                
                goal_response = ""
                for chunk in goal_check:
                    if hasattr(chunk.choices[0].delta, 'content'):
                        content = chunk.choices[0].delta.content
                        if content is not None:
                            goal_response += content
                
                if "yes" in goal_response.lower():
                    st.success("üí´ Regenerative solution achieved! Generating detailed summary...")
                    
                    summary = generate_summary_doc(st.session_state.messages, goal)
                    if summary:
                        # Create and save document
                        doc_io = create_formatted_docx(summary, goal, st.session_state.messages)
                        
                        if doc_io:
                            # Create download button
                            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                            st.download_button(
                                label="üì• Download Detailed Summary",
                                data=doc_io,
                                file_name=f"regenerative_solution_{timestamp}.docx",
                                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                            )
                            
                            # Display success message
                            st.success("‚úÖ Document generated successfully! Click above to download.")
                        else:
                            st.error("Failed to generate document. Please try again.")
                    break
            
            time.sleep(0.5)
    
    if st.button("Reset"):
        st.session_state.messages = []
        st.experimental_rerun()

if __name__ == "__main__":
    main()